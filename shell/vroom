#!/bin/zsh
# 30/08/2018 update - will only switch to a branch if
# provided as first argument; will warn if changes
# 10/06/2019 update - branch is now -b
# 03/09/2019 update - massive overhaul, adding `start:local`, adding project config
# 03/09/2020 update - annual overhaul
version=9.23.1
usage="$(basename "$0") [-hdelLstv] Five main parts: base, setup, run, watch, destroy. Logs to STDOUT unless -l is provided.
â€¢ With no paramters, assumes -r, if [dsw] then -r is not assumed and must be explicitly requested
â€¢ Base: handled internally based on language, package manager, etc.
â€¢ Destroy: generally undoes all the things that Setup does.
â€¢ Setup: Setting up linking, cleaning dist/node_modules, etc. Default is no-op
  * Avoid using 'npm ci' or 'pipenv install'; these will be called in Base.
â€¢ Run: Main executor of your project locally. Default is best-guess
â€¢ Watch: When RunCmd exits (e.g., containerized), use this to run a long-running 'watch' command
*NOTE: Setup, Run, and Destroy are defined by local .vroom file.

Config file (.vroom):
For multiple short commands, use semi-colon, e.g.:
  runCmd=cmd1; cmd2; cmd3
Also supports multi-line commands using standard terminal-backslash, e.g.:
  runCmd=cmd1 \\
    cmd2 \\
    cmd3 # Note no backslash on last line

Supported auto-configure platforms are
â€¢ Docker / Docker-Compose
â€¢ Python (with Pipfile)
â€¢ NPM (with package.json)
â€¢ Yarn (with yarn.lock)
â€¢ PHP/Composer (with composer.json)

Other platforms can still be setup manually; just start with vroom -e

Options:
  -h show this message
  -e edit config
  -p print config
  -f fast mode, skip Base setup
  -l log to server.log or provided -L param
  -L Change output file (implies -l)
  -s execute Setup command
  -w execute Watch command  after other operations
  -d execute Destroy command
  -v Prints version info

Examples: (assumes a NodeJS yarn project, note that 'yarn install' is part of internal Base)
  vroom: Setup NVM, switch to the right NPM version, do 'yarn install', and execute the RunCmd
  vroom -f: Setup NVM, switch to the right NPM version, execute the runCmd
  vroom -l: Setup NVM, switch to the right NPM version, do 'yarn install', execute the runCmd, log all to 'server.log'
  vroom -e: Edit .vroom file from current directory
  vroom -p: Print .vroom file from current directory
  vroom -s: Setup NVM, switch to the right NPM version, do 'yarn install', execute the setupCmd
  vroom -fr: Setup NVM, switch to the right NPM version, execute the runCmd
  vroom -sr: Setup NVM, switch to the right NPM version, do 'yarn install', execute setupCmd then runCmd
  vroom -lrs: Setup NVM, switch to the right NPM version, do 'yarn install', and execute the RunCmd, log all to 'server.log'
  vroom -d: Setup NVM, switch to the right NPM version, do 'yarn install', execute the destroyCmd
  vroom -dfsr: Setup NVM, switch to the right NPM version, execute destroyCmd, skip Base, execute setupCmd then runCmd"

echo_cmd() {
  echo $(echo $1 | sed 's/;/;\\n/g')
}

base_project() {
  if [ -d '.git' ]; then
    changes=$(git diff --name-only)
  fi
  files=$(ls -al)

  # Check for project type
  if [ -f "docker-compose-local.yml" ]; then
    manager="docker-compose -f docker-compose-local.yml"
    setup="build"
  elif [ -f "docker-compose.yml" ]; then
    manager="docker-compose"
    setup="build"
  elif [ -f "Dockerfile" ]; then
    manager="docker"
    setup="build -t $(basename $(pwd):1) ."
  elif [[ "$files" =~ ".nvmrc" ]]; then
    # Node w/ NVM/NPM/Yarn/etc.
    echo_cmd "Found .nvmrc file; wiring up NVM"
    # assume things are wired up normally
    source "$NVM_DIR/nvm.sh" > /dev/null 2>&1
    # this is the old style, so support it for now
    if [ $? -ne 0 ]; then
      export NVM_DIR="$HOME/.nvm"
      . "/usr/local/opt/nvm/nvm.sh"
    fi
    nvm install
    if [[ "$files" =~ "yarn.lock" ]]; then
      manager="yarn"
      setup='install'
    else
      manager="npm"
      available=$(npm)
      if [[ "$available" =~ " ci," ]]; then
        setup="ci"
      else
        setup="install"
      fi
    fi
  elif [ -f 'composer.json' ]; then
    # PHP
    manager="composer"
    setup="install"
  elif [ -f 'Pipfile' ]; then
    # Python
    manager="pipenv"
    setup="install"
  fi

  if [ -n "$manager" ]; then
    if [ -z "$fastMode" ]; then
      echo_cmd "Installing dependencies with $manager $setup"
      eval "$manager $setup"
    else
      echo "Fast Mode: Skipping initial $manager $setup"
    fi
  fi
}

configure_setup() {
  if [ -z "$setupCmd" ] || [ -n "$newSetupCommand" ]; then
    updateConfig="true"
    if [ -n "$newSetupCommand" ]; then
      setupCmd="$newSetupCommand"
    else
      destroyCmd="echo 'Basic install in Base; Have a ðŸ¥ƒ while you consider any special cases'"
      setupCmd="$manager $setup"
    fi
  fi
}

configure_destroy() {
  if [ -z "$destroyCmd" ] || [ -n "$newDestroyCommand" ]; then
    updateConfig="true"
    if [ -n "$newDestroyCommand" ]; then
      destroyCmd="$newDestroyCommand"
    else
      destroyCmd="echo 'Chill. Have a ðŸ¥ƒ'"
    fi
  fi
}

configure_watch() {
  if [ -z "$watchCmd" ] || [ -n "$newWatchCommand" ]; then
    updateConfig="true"
    if [ -n "$newWatchCommand" ]; then
      watchCmd="$newWatchCommand"
    else
      watchCmd="echo 'Why not watch a ðŸ¥ƒ'"
    fi
  fi
}

configure_run() {
  if [ -z "$runCmd" ] || [ -n "$newRunCommand" ]; then
    updateConfig="true"
    if [ -n "$newRunCommand" ]; then
      runCmd="$newRunCommand"
    else
      set_default_run
    fi
  fi
}

set_default_run() {
  if [ -f "docker-compose-local.yml" ] || [ -f "docker-compose.yml" ]; then
    if [ -f "docker-compose-local.yml" ]; then
      src="docker-compose-local.yml"
    else
      src="docker-compose.yml"
    fi
    target=$(sed -e "s/.*target:[ *]//;t1" -e "d" -e ":1" -e "q" "$src")
    runCmd="$manager run $target"
  elif [ -f "Dockerfile" ]; then
    runCmd="$manager run $(basename $(pwd):1)"
  elif [ -f "Pipfile" ]; then
    runCmd="echo \"\e[31;47mCan't predict Python main file! Run \e[32m'vroom -e'\e[31m and set runCmd to your start command!\e[0m\""
  else
    # NPM-based projects will return a list of valid commands from the `run` command
    # checks for, in order, `start:local`, `start:dev`, `dev`, `start` as default
    scripts=$(eval "$manager run")
    if [[ "$scripts" =~ '[[:space:]]+start:local[[:space:]]+' ]]; then
      runCmd="$manager run start:local"
    elif [[ "$scripts" =~ '[[:space:]]+start:dev[[:space:]]+' ]]; then
      runCmd="$manager run start:dev"
    elif [[ "$scripts" =~ '[[:space:]]+dev[[:space:]]+' ]]; then
      runCmd="$manager run dev"
    else
      runCmd="$manager run start"
    fi
  fi
}

editConfig() {
  if [ ! -f '.vroom' ]; then
    echo "setupCmd=\nrunCmd=\nwatchCmd=\ndestroyCmd=" > .vroom
  fi
  vi .vroom
}

while getopts ':hepfdlrstwvL:' option; do
  case "$option" in
    h) echo "$usage"
      exit
      ;;
    d) doDestroy="true"
      ;;
    e) editConfig
      exit
      ;;
    p) cat .vroom
      exit
      ;;
    f) fastMode="true"
      ;;
    L) logFile="$OPTARG"
      ;;
    l) logToFile="true"
      ;;
    r) doRun="true"
      ;;
    s) doSetup="true"
      ;;
    w) doWatch="true"
      ;;
    v) echo "$version"
      exit
      ;;
  esac
done
shift $((OPTIND -1))

if [ -z "$doDestroy" ] && [ -z "$doSetup" ] && [ -z "$doWatch" ]; then
  doRun="true"
fi

if [ -n "$logToFile" ] || [ -n "$logFile" ]; then
  if [ -z "$logFile" ]; then
    logFile="server.log"
  fi
  echo "\033[0;31mrun 'less +F $logFile' to see the logs.\033[0m"
  # holy moly, exec redirects script output!
  exec > $logFile
  exec 2>&1
fi
# sets changes, files, manager, and setup
base_project

# Handle updating unchanged branch
if [ -d ".git" ] && [ -z "$changes" ]; then
  eval "echo 'no local changes, pulling from origin' $cmdSuffix";
  git pull > /dev/null 2>&1
fi

config="$(pwd)/.vroom"
if [ -f "$config" ]; then
  while read -r line; do
    fullLine="$fullLine$line"
    if [[ "${line: -1}" == '\' ]]; then
      # to allow trailing-slash syntax in config file for readibility,
      # need to manually parse/handle them. First, restore the \\ and \n
      fullLine="$fullLine"'\\n '
    else
      if [ -n "$fullLine" ] && [[ "$fullLine" != "#"* ]]; then
        declare "$fullLine"
      else
        configComments="$line$configComments"
      fi
      fullLine=""
    fi
  done < "$config"
else
  updateConfig="true"
fi

configure_setup
configure_run
configure_watch
configure_destroy

# Write out the config if changed
if [ -n "$updateConfig" ]; then
  rm $config
  if [ -n "$configComments" ]; then
    echo "$configComments" >> $config
  fi
  #echo "setupCmd=$(setupCmd//';'/';\n')" >> $config
  echo "setupCmd=$setupCmd" >> $config
  echo "runCmd=$runCmd" >> $config
  echo "watchCmd=$watchCmd" >> $config
  echo "destroyCmd=$destroyCmd" >> $config
fi

# If we added characters to support trailing slashes,
# remove them *and* the slash before execution
setupCmd=${setupCmd//'\\\n'}
runCmd=${runCmd//'\\\n'}
watchCmd=${watchCmd//'\\\n'}
destroyCmd=${destroyCmd//'\\\n'}

if [[ "$doDestroy" == "true" ]]; then
  echo_cmd "running destroy [$destroyCmd]"
  eval "$destroyCmd"
fi

if [[ "$doSetup" == "true" ]]; then
  echo_cmd "running setup [$setupCmd]"
  eval "$setupCmd"
fi

if [[ "$doRun" == "true" ]]; then
  echo_cmd "running Run [$runCmd]"
  eval "$runCmd"
fi

if [[ "$doWatch" == "true" ]]; then
  echo_cmd "running watch [$watchCmd]"
  eval "$watchCmd"
fi
