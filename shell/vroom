#!/bin/zsh
# 30/08/2018 update - will only switch to a branch if
# provided as first argument; will warn if changes
# 10/06/2019 update - branch is now -b
# 03/09/2019 update - massive overhaul, adding `start:local`, adding project config
usage="$(basename "$0") [-holeEbrRwW] Attempts to run the project in pwd.
If branch provided, tries to switch to it first then pulls latest. Then determines commands to use by using provided
commands, .vroom file, or defaults (in that order). If defaulting the 'run' command it searches for, in priority order:
[start:local], [dev], [start].
Uses NVM to install NPM, pyenv to install python, then if -l is specified begins logging to -o file (or 'server.log')
If 'yarn.lock' is discovered in project, installs with yarn, otherwise installs with npm, resets if -r is provided, 
  executes 'run' command, then executes 'watch' command if -w is proivded.
  -l Log to server.log
  -o Change output file (defaults to server.log)
  -b Provide branch to switch to; will prompt if there are changes
  -e Re-evaluate the 'run' command
  -E Sets the run command
  -r Run 'reset' command before start command (defaults to npm run nuke)
  -R Sets the reset command
  -w Run 'watch' command after start command (defaults to npm run watch)
  -W Sets the watch command"

while getopts ':hwW:rR:eE:knlo:b:' option; do
  case "$option" in
    h) echo "$usage"
       exit
       ;;
    n) echo "logging to std out is now the default. If you want to log to a file, use -l"
      ;;
    o) logFile="$OPTARG"
      ;;
    l) logToFile="true"
      ;;
    e) refind="true"
      ;;
    E) newRunCmd="$OPTARG"
      ;;
    b) branch=$OPTARG
      ;;
    r) reset="true"
      ;;
    R) newResetCmd="$OPTARG"
      ;;
    w) watch="true"
      ;;
    W) newWatchCmd="$OPTARG"
      ;;
  esac
done
shift $((OPTIND -1))

# Handle branch switching/pulling
changes=$(git diff --name-only)
if [ -n "$branch" ] ; then
  if [ -n "$changes" ] ; then
    read "destroy?You have local changes; Really switch branches? 'em? (y): "
  fi
  if [ -z "$destroy" ] || [ "$destroy" = "y" ] || [ "$destroy" = "yes" ] ; then
    git reset --hard
    git checkout $branch
    git pull
  else
    echo "Local changes untouched"
    exit 1
  fi
else
  if [ -z "$changes" ] ; then
    git pull
  fi
fi

# Setup "Dependencies" (NVM and Python)
export NVM_DIR="$HOME/.nvm"
. "/usr/local/opt/nvm/nvm.sh"
nvm install
echo "If you don't use pyenv and your run script needs python, you might need to do some trickery; goatspeed"
pyenv init -

# Get configured commands, if any
config="$(pwd)/.vroom"
if [ -f "$config" ] ; then
  while read -r line; do declare "$line"; done < "$config"
fi

# If we got new commands, set them
if [ -n "$newResetCmd" ] ; then
  resetCmd="$newResetCmd"
elif [ -z "$resetCmd" ] ; then
  resetCmd="npm run nuke"
fi

if [ -n "$newWatchCmd" ] ; then
  watchCmd="$newWatchCmd"
elif [ -z "$watchCmd" ] ; then
  watchCmd="npm run watch"
fi

# Determine setup command
files=$(ls)
if [[ "$files" == *"yarn"* ]] ; then
  setupCmd="echo 'Installing with Yarn';yarn install"
  runCmdNewBase="yarn run"
else
  setupCmd="echo 'Installing with NPM';npm ci > /dev/null 2>&1 || npm install"
  runCmdNewBase="npm run"
fi

if [ -n "$newRunCmd" ] ; then
  runCmd="$newRunCmd"
elif [ -z "$runCmd" ] || [ -n "$refind" ] ; then
  runCmdNew=runCmdNewBase
  # Defaults for run command aren't as easy
  scripts=$(eval "$runCmdNew")
  if [[ "$scripts" =~ '[[:space:]]+start:local[[:space:]]+' ]] ; then
    runCmd="$runCmdNew start:local"
  elif [[ "$scripts" =~ '[[:space:]]+dev[[:space:]]+' ]] ; then
    runCmd="$runCmdNew dev"
  else
    runCmd="$runCmdNew start"
  fi
fi

# Write out the config
echo "resetCmd=$resetCmd" > $config
echo "watchCmd=$watchCmd" >> $config
echo "runCmd=$runCmd" >> $config

if [ -n "$logToFile" ] ; then
  if [ -z "$logFile" ] ; then
    logFile="server.log"
  fi
  echo "\033[0;31mrun 'less +F $logFile' to see the logs.\033[0m"
  setupCmd=$(echo "$setupCmd" | sed -e 's%/dev/null%'$logFile'%')
  setupCmd="$setupCmd >> \"$logFile\" 2>&1"
  resetCmd="$resetCmd >> \"$logFile\" 2>&1"
  runCmd="$runCmd >> \"$logFile\" 2>&1"
  watchCmd="$watchCmd >> \"$logFile\" 2>&1"
fi

#DO WORK SON
echo "setting up [$setupCmd]"
eval "$setupCmd"
if [ -n "$reset" ] ; then
  echo "trying to reset [$resetCmd]"
  eval "$resetCmd"
fi
echo "Running [$runCmd]"
eval "$runCmd"
if [ -n "$watch" ] ; then
  echo "Watching [$watchCmd]"
  eval "$watchCmd"
fi

